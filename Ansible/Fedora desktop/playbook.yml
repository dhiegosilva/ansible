- name: Configure Fedora 42 Environment AMD laptop (zRAM-only swap)
  hosts: fedora
  gather_facts: false
  become: true
  become_method: sudo
  vars:
    flatpak_update_script: /usr/local/bin/flatpak-auto-update.sh
    gnome_user: dhiego
    gnome_xauthority: "/home/dhiego/.Xauthority"

  pre_tasks:
    - name: Bootstrap python3-libdnf5 so dnf module works
      ansible.builtin.raw: dnf -y install python3-libdnf5
      register: libdnf_bootstrap
      changed_when: >
        'Complete!' in libdnf_bootstrap.stdout or
        'installed' in libdnf_bootstrap.stdout or
        'Nichts zu tun' in libdnf_bootstrap.stdout or
        'ist bereits installiert' in libdnf_bootstrap.stdout
      failed_when: false

    - name: Gather facts
      ansible.builtin.setup:

    - name: Enable lingering for {{ gnome_user }}
      ansible.builtin.command: loginctl enable-linger {{ gnome_user }}
      register: linger_result
      changed_when: linger_result.rc == 0
      failed_when: false

    - name: Get {{ gnome_user }} RuntimePath
      ansible.builtin.command: loginctl show-user {{ gnome_user }} -p RuntimePath --value
      register: user_runtime
      changed_when: false
      failed_when: false

    - name: Check XAUTHORITY file
      ansible.builtin.stat:
        path: "{{ gnome_xauthority }}"
      register: xauth_stat

  tasks:
    # ===== Swap: keep ONLY zRAM enabled =====
    - name: List active non-zram swap devices/files (exclude zram by name)
      ansible.builtin.shell: |
        swapon --noheadings --show=NAME | awk '!/\/zram[0-9]+$/ {print $1}'
      register: nonzram_swaps
      changed_when: false
      failed_when: false

    - name: Disable non-zram swaps (leave zram enabled)
      ansible.builtin.command: swapoff {{ item }}
      loop: "{{ nonzram_swaps.stdout_lines }}"
      when: nonzram_swaps.stdout != ""

    - name: Remove any swap entry from fstab (prevents disk swap)
      ansible.builtin.lineinfile:
        path: /etc/fstab
        regexp: '^\s*([^#]\S+)\s+\S+\s+swap\s'
        state: absent

    - name: Ensure no disk swapfile exists
      ansible.builtin.file:
        path: /swapfile
        state: absent

    - name: Ensure zram generator packages are installed
      ansible.builtin.dnf:
        name:
          - zram-generator
          - zram-generator-defaults
        state: present

    - name: Configure zram (RAM x2, zstd compression)
      ansible.builtin.copy:
        dest: /etc/systemd/zram-generator.conf
        owner: root
        group: root
        mode: '0644'
        content: |
          [zram0]
          zram-size = ram * 2
          compression-algorithm = zstd
          swap-priority = 100

    - name: Reload systemd units after zram config
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Start zram swap (dev-zram0.swap)
      ansible.builtin.systemd:
        name: dev-zram0.swap
        state: started
        enabled: true
      register: devzram_result
      failed_when: false

    - name: Verify zram is active
      ansible.builtin.shell: swapon --noheadings --show=NAME | awk '/\/zram[0-9]+$/ {print $1}'
      register: zram_active
      changed_when: false

    - name: Fail if no zram swap is active
      ansible.builtin.fail:
        msg: "zRAM not active after attempting to start dev-zram0.swap."
      when: zram_active.stdout == ""

    # ===== Flatpak base =====
    - name: Ensure flatpak is installed
      ansible.builtin.dnf:
        name: flatpak
        state: present

    - name: Add Flathub remote (idempotent)
      ansible.builtin.shell: |
        set -e
        if ! flatpak remote-list --columns=name | grep -qx flathub; then
          flatpak remote-add flathub https://flathub.org/repo/flathub.flatpakrepo
          echo ADDED
        fi
      args: { executable: /bin/bash }
      register: flathub_add
      changed_when: "'ADDED' in flathub_add.stdout"

    - name: Install Flatpak apps
      community.general.flatpak:
        name: "{{ item }}"
        state: present
        remote: flathub
      loop:
        - com.brave.Browser
        - io.github.peazip.PeaZip
        - com.github.tchx84.Flatseal
        - org.videolan.VLC
        - org.gnome.meld
        - io.dbeaver.DBeaverCommunity
        - org.remmina.Remmina
        - com.ultimaker.cura
        - com.valvesoftware.Steam
        - org.gimp.GIMP

    # GNOME Tweaks via DNF (Flatpak not present)
    - name: Install GNOME Tweaks (DNF)
      ansible.builtin.dnf:
        name: gnome-tweaks
        state: present

    # ===== VS Code =====
    - name: Import Microsoft GPG key
      ansible.builtin.rpm_key:
        state: present
        key: https://packages.microsoft.com/keys/microsoft.asc

    - name: Add VS Code repo
      ansible.builtin.copy:
        dest: /etc/yum.repos.d/vscode.repo
        content: |
          [code]
          name=Visual Studio Code
          baseurl=https://packages.microsoft.com/yumrepos/vscode
          enabled=1
          gpgcheck=1
          gpgkey=https://packages.microsoft.com/keys/microsoft.asc

    - name: Install VS Code via command (dnf5 quirk workaround)
      ansible.builtin.command: dnf install -y code
      register: vscode_install
      changed_when: "'Nothing to do' not in vscode_install.stdout and 'Nichts zu tun' not in vscode_install.stdout"

    # ===== SSH config =====
    - name: Permit root SSH login
      ansible.builtin.lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitRootLogin'
        line: 'PermitRootLogin yes'

    - name: Permit password SSH
      ansible.builtin.lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication yes'

    - name: Restart SSH
      ansible.builtin.systemd:
        name: sshd
        state: restarted

    - name: Set root password
      ansible.builtin.user:
        name: root
        password: '{{ "f4x4d8p6" | password_hash("sha512") }}'

    # ===== GNOME cleanup =====
    - name: Remove unoconv first to avoid dependency conflict with libreoffice removal
      ansible.builtin.dnf:
        name: unoconv
        state: absent

    - name: Remove GNOME packages and applications you donâ€™t need
      ansible.builtin.dnf:
        name:
          - evince
          - gnome-logs
          - libreoffice*
          - totem
          - rhythmbox
          - gnome-maps
          - gnome-contacts
          - gnome-weather
          - gnome-boxes
          - 'abrt-addon-*'
          - 'abrt-cli'
          - 'abrt-desktop'
          - 'abrt-dbus'
          - 'abrt-gui*'
          - 'abrt-tui'
          - 'abrt-plugin-bodhi'
          - gnome-abrt
          - 'brltty*'
          - 'speech-dispatcher*'
          - espeak-ng
          - orca
          - brcmfmac-firmware
          - cirrus-audio-firmware
          - intel-audio-firmware
          - intel-gpu-firmware
          - intel-vsc-firmware
          - iwlegacy-firmware
          - iwlwifi-dvm-firmware
          - libertas-firmware
          - mt7xxx-firmware
          - nxpwireless-firmware
          - realtek-firmware
          - tiwilink-firmware
          - rygel
          - gnome-tour
          - gnome-clocks
          - gnome-connections
          - gnome-user-docs
          - 'anaconda*'
          - 'python3-meh*'
          - ModemManager
          - pcsc-lite
          - fwupd
          - sssd-kcm
          - snapshot
        state: absent
        allowerasing: yes

    # ===== GNOME Software (handle dnf4/dnf5 differences) =====
    - name: Ensure GNOME Software is present
      ansible.builtin.dnf:
        name: gnome-software
        state: present

    - name: Check if Flatpak plugin package exists
      ansible.builtin.shell: dnf -q info gnome-software-plugin-flatpak
      register: flatpak_plugin_check
      changed_when: false
      failed_when: false

    - name: Install GNOME Software Flatpak plugin when available
      ansible.builtin.dnf:
        name: gnome-software-plugin-flatpak
        state: present
      when: flatpak_plugin_check.rc == 0

    # ===== Fish + Tilix =====
    - name: Install Fish
      ansible.builtin.dnf:
        name: fish
        state: present

    - name: Default shell fish
      ansible.builtin.user:
        name: dhiego
        shell: /usr/bin/fish

    - name: Install Tilix
      ansible.builtin.dnf:
        name: tilix
        state: present

    # ===== Flatpak Auto-Update (after boot, no logging) =====
    - name: Populate update script (no logging)
      ansible.builtin.copy:
        dest: '{{ flatpak_update_script }}'
        content: |
          #!/usr/bin/env bash
          set -euo pipefail
          flatpak update -y
        owner: root
        group: root
        mode: '0755'

    - name: Deploy Flatpak auto-update service (run at boot)
      ansible.builtin.copy:
        dest: /etc/systemd/system/flatpak-auto-update.service
        content: |
          [Unit]
          Description=Flatpak auto-update at boot
          Wants=network-online.target
          After=network-online.target
          ConditionNetworkOnline=yes

          [Service]
          Type=oneshot
          ExecStart={{ flatpak_update_script }}
          StandardOutput=journal
          StandardError=journal
        owner: root
        group: root
        mode: '0644'

    - name: Deploy Flatpak auto-update timer (boot only)
      ansible.builtin.copy:
        dest: /etc/systemd/system/flatpak-auto-update.timer
        content: |
          [Unit]
          Description=Run Flatpak auto-update after boot only

          [Timer]
          OnBootSec=2min

          [Install]
          WantedBy=timers.target
        owner: root
        group: root
        mode: '0644'
  
    - name: Enable Flatpak timer
      ansible.builtin.systemd:
        daemon_reload: yes
        name: flatpak-auto-update.timer
        enabled: yes
        state: started

    # ===== GRUB Configuration =====
    - name: Set GRUB_TIMEOUT to 2 seconds
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_TIMEOUT='
        line: 'GRUB_TIMEOUT=2'
      register: grub_timeout_changed

    - name: Set optimized GRUB_CMDLINE_LINUX_DEFAULT for performance
      ansible.builtin.lineinfile:
        path: /etc/default/grub
        regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
        line: 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash mitigations=off nowatchdog nosoftlockup amd_pstate=active pcie_aspm=performance"'
      register: grub_cmdline_changed

    - name: Update GRUB if configuration changed
      ansible.builtin.command: grub2-mkconfig -o /boot/grub2/grub.cfg
      when: grub_timeout_changed.changed or grub_cmdline_changed.changed

    - name: Rebuild initramfs (dracut) if kernel cmdline changed
      ansible.builtin.command: dracut --force
      when: grub_cmdline_changed.changed

    # ===== GNOME Extensions (guarded for headless SSH) =====
    - name: Install Dash-to-Dock GNOME extension
      become: false
      ansible.builtin.shell: |
        set -e
        EXT_ID=307
        GNOME_SHELL_VER=$(gnome-shell --version | grep -oE '[0-9]+' | head -1)
        INFO=$(curl -s "https://extensions.gnome.org/extension-info/?pk=${EXT_ID}&shell_version=${GNOME_SHELL_VER}")
        UUID=$(echo "$INFO" | grep -oP '"uuid":\s*"\K[^"]+')
        DOWNLOAD_URL=$(echo "$INFO" | grep -oP '"download_url":\s*"\K[^"]+')
        ZIPURL="https://extensions.gnome.org${DOWNLOAD_URL}"
        TMPZIP="/tmp/${UUID}.zip"
        curl -L -o "$TMPZIP" "$ZIPURL"
        gnome-extensions install --force "$TMPZIP"
        gnome-extensions enable "$UUID"
        echo "Installed & enabled"
      args: { executable: /bin/bash }
      environment:
        DISPLAY: ":0"
        XAUTHORITY: "{{ gnome_xauthority }}"
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      become_user: "{{ gnome_user }}"
      register: gnome_ext_dash
      changed_when: "'Installed & enabled' in gnome_ext_dash.stdout"
      when:
        - xauth_stat.stat.exists
        - user_runtime.stdout is defined
        - user_runtime.stdout | length > 0

    - name: Install Burn My Windows GNOME extension
      become: false
      ansible.builtin.shell: |
        set -e
        EXT_ID=4679
        GNOME_SHELL_VER=$(gnome-shell --version | grep -oE '[0-9]+' | head -1)
        INFO=$(curl -s "https://extensions.gnome.org/extension-info/?pk=${EXT_ID}&shell_version=${GNOME_SHELL_VER}")
        UUID=$(echo "$INFO" | grep -oP '"uuid":\s*"\K[^"]+')
        DOWNLOAD_URL=$(echo "$INFO" | grep -oP '"download_url":\s*"\K[^"]+')
        ZIPURL="https://extensions.gnome.org${DOWNLOAD_URL}"
        TMPZIP="/tmp/${UUID}.zip"
        curl -L -o "$TMPZIP" "$ZIPURL"
        gnome-extensions install --force "$TMPZIP"
        gnome-extensions enable "$UUID"
        echo "Installed & enabled"
      args: { executable: /bin/bash }
      environment:
        DISPLAY: ":0"
        XAUTHORITY: "{{ gnome_xauthority }}"
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      become_user: "{{ gnome_user }}"
      register: gnome_ext_burn
      changed_when: "'Installed & enabled' in gnome_ext_burn.stdout"
      when:
        - xauth_stat.stat.exists
        - user_runtime.stdout is defined
        - user_runtime.stdout | length > 0

    - name: Install OpenWeather GNOME extension
      become: false
      ansible.builtin.shell: |
        set -e
        EXT_ID=750
        GNOME_SHELL_VER=$(gnome-shell --version | grep -oE '[0-9]+' | head -1)
        INFO=$(curl -s "https://extensions.gnome.org/extension-info/?pk=${EXT_ID}&shell_version=${GNOME_SHELL_VER}")
        UUID=$(echo "$INFO" | grep -oP '"uuid":\s*"\K[^"]+')
        DOWNLOAD_URL=$(echo "$INFO" | grep -oP '"download_url":\s*"\K[^"]+')
        ZIPURL="https://extensions.gnome.org${DOWNLOAD_URL}"
        TMPZIP="/tmp/{{ gnome_user }}-{{ EXT_ID }}.zip"
        curl -L -o "$TMPZIP" "$ZIPURL"
        gnome-extensions install --force "$TMPZIP"
        gnome-extensions enable "$UUID"
        echo "Installed & enabled"
      args: { executable: /bin/bash }
      environment:
        DISPLAY: ":0"
        XAUTHORITY: "{{ gnome_xauthority }}"
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      become_user: "{{ gnome_user }}"
      register: gnome_ext_openweather
      changed_when: "'Installed & enabled' in gnome_ext_openweather.stdout"
      when:
        - xauth_stat.stat.exists
        - user_runtime.stdout is defined
        - user_runtime.stdout | length > 0

    - name: Install No Overview GNOME extension
      become: false
      ansible.builtin.shell: |
        set -e
        EXT_ID=4099
        GNOME_SHELL_VER=$(gnome-shell --version | grep -oE '[0-9]+' | head -1)
        INFO=$(curl -s "https://extensions.gnome.org/extension-info/?pk=${EXT_ID}&shell_version=${GNOME_SHELL_VER}")
        UUID=$(echo "$INFO" | grep -oP '"uuid":\s*"\K[^"]+')
        DOWNLOAD_URL=$(echo "$INFO" | grep -oP '"download_url":\s*"\K[^"]+')
        ZIPURL="https://extensions.gnome.org${DOWNLOAD_URL}"
        TMPZIP="/tmp/{{ gnome_user }}-{{ EXT_ID }}.zip"
        curl -L -o "$TMPZIP" "$ZIPURL"
        gnome-extensions install --force "$TMPZIP"
        gnome-extensions enable "$UUID"
        echo "Installed & enabled"
      args: { executable: /bin/bash }
      environment:
        DISPLAY: ":0"
        XAUTHORITY: "{{ gnome_xauthority }}"
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      become_user: "{{ gnome_user }}"
      register: gnome_ext_nooverview
      changed_when: "'Installed & enabled' in gnome_ext_nooverview.stdout"
      when:
        - xauth_stat.stat.exists
        - user_runtime.stdout is defined
        - user_runtime.stdout | length > 0

    # ===== I/O scheduler =====
    - name: Set I/O scheduler to mq-deadline for NVMe device
      ansible.builtin.copy:
        dest: /etc/udev/rules.d/60-ioschedulers.rules
        content: |
          ACTION=="add|change", KERNEL=="nvme0n1", ATTR{queue/scheduler}="mq-deadline"
        owner: root
        group: root
        mode: '0644'

    - name: Reload udev rules to apply I/O scheduler
      ansible.builtin.command: udevadm control --reload-rules

    # ===== sysctl fq + bbr =====
    - name: Configure sysctl settings for fq and bbr
      ansible.builtin.copy:
        dest: /etc/sysctl.d/99-network-performance.conf
        content: |
          net.core.default_qdisc = fq
          net.ipv4.tcp_congestion_control = bbr
        owner: root
        group: root
        mode: '0644'

    - name: Apply sysctl settings
      ansible.builtin.command: sysctl --system

    - name: Show current TCP congestion control algorithm
      ansible.builtin.command: sysctl net.ipv4.tcp_congestion_control
      register: tcp_cc

    - name: Print TCP congestion control
      ansible.builtin.debug:
        var: tcp_cc.stdout

    # ===== Bluetooth SBC XQ Max Quality =====
    - name: Ensure bluetooth.lua.d override directory exists
      ansible.builtin.file:
        path: /etc/wireplumber/bluetooth.lua.d
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Configure SBC XQ to use only maximum bitpool (53) in WirePlumber
      ansible.builtin.copy:
        dest: /etc/wireplumber/bluetooth.lua.d/51-bluez-config.lua
        owner: root
        group: root
        mode: '0644'
        content: |
          bluez_monitor.properties = {
            ["bluez5.enable-sbc-xq"] = true,
            ["bluez5.sbc-xq-min-bitpool"] = 53,
            ["bluez5.sbc-xq-max-bitpool"] = 53,
          }

    - name: Restart WirePlumber (user service)
      ansible.builtin.systemd:
        name: wireplumber
        state: restarted
        scope: user
      become_user: "{{ gnome_user }}"
      environment:
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      when: user_runtime.stdout is defined and user_runtime.stdout | length > 0

    - name: Restart PipeWire (user service)
      ansible.builtin.systemd:
        name: pipewire
        state: restarted
        scope: user
      become_user: "{{ gnome_user }}"
      environment:
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      when: user_runtime.stdout is defined and user_runtime.stdout | length > 0

    - name: Restart PipeWire Pulse bridge (user service)
      ansible.builtin.systemd:
        name: pipewire-pulse
        state: restarted
        scope: user
      become_user: "{{ gnome_user }}"
      environment:
        XDG_RUNTIME_DIR: "{{ user_runtime.stdout | default('') }}"
      when: user_runtime.stdout is defined and user_runtime.stdout | length > 0

    # ===== DNF / DNF5 Automatic Updates (works on Fedora 40â€“42) =====
    - name: Try install dnf5 automatic plugin (Fedora 41+)
      ansible.builtin.dnf:
        name: dnf5-plugin-automatic
        state: present
      register: dnf5_auto_pkg
      failed_when: false

    - name: Try install legacy dnf-automatic (Fedora â‰¤40 or still available)
      ansible.builtin.dnf:
        name: dnf-automatic
        state: present
      register: dnf4_auto_pkg
      failed_when: false

    - name: Ensure config dirs exist (dnf4 & dnf5)
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - /etc/dnf
        - /etc/dnf/dnf5-plugins

    - name: Write /etc/dnf/automatic.conf (legacy path; also read by dnf5)
      ansible.builtin.copy:
        dest: /etc/dnf/automatic.conf
        mode: '0644'
        content: |
          [commands]
          apply_updates = True
          reboot = no
      when: dnf4_auto_pkg is succeeded or dnf5_auto_pkg is succeeded

    - name: Write /etc/dnf/dnf5-plugins/automatic.conf (dnf5 plugin path)
      ansible.builtin.copy:
        dest: /etc/dnf/dnf5-plugins/automatic.conf
        mode: '0644'
        content: |
          [commands]
          apply_updates = True
          reboot = no
      when: dnf5_auto_pkg is succeeded

    - name: Enable/start dnf5-automatic.timer (Fedora 41+)
      ansible.builtin.systemd:
        name: dnf5-automatic.timer
        enabled: true
        state: started
      register: dnf5_timer
      failed_when: false

    - name: Enable/start dnf-automatic.timer (legacy fallback)
      ansible.builtin.systemd:
        name: dnf-automatic.timer
        enabled: true
        state: started
      when: dnf5_timer is failed or dnf5_timer is skipped
      failed_when: false
